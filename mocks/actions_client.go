// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"sync"

	"github.com/google/go-github/v41/github"
)

type ActionsClient struct {
	AddRepositoryAccessRunnerGroupStub        func(context.Context, string, int64, int64) (*github.Response, error)
	addRepositoryAccessRunnerGroupMutex       sync.RWMutex
	addRepositoryAccessRunnerGroupArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 int64
	}
	addRepositoryAccessRunnerGroupReturns struct {
		result1 *github.Response
		result2 error
	}
	addRepositoryAccessRunnerGroupReturnsOnCall map[int]struct {
		result1 *github.Response
		result2 error
	}
	CreateOrganizationRegistrationTokenStub        func(context.Context, string) (*github.RegistrationToken, *github.Response, error)
	createOrganizationRegistrationTokenMutex       sync.RWMutex
	createOrganizationRegistrationTokenArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	createOrganizationRegistrationTokenReturns struct {
		result1 *github.RegistrationToken
		result2 *github.Response
		result3 error
	}
	createOrganizationRegistrationTokenReturnsOnCall map[int]struct {
		result1 *github.RegistrationToken
		result2 *github.Response
		result3 error
	}
	CreateOrganizationRemoveTokenStub        func(context.Context, string) (*github.RemoveToken, *github.Response, error)
	createOrganizationRemoveTokenMutex       sync.RWMutex
	createOrganizationRemoveTokenArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	createOrganizationRemoveTokenReturns struct {
		result1 *github.RemoveToken
		result2 *github.Response
		result3 error
	}
	createOrganizationRemoveTokenReturnsOnCall map[int]struct {
		result1 *github.RemoveToken
		result2 *github.Response
		result3 error
	}
	CreateOrganizationRunnerGroupStub        func(context.Context, string, github.CreateRunnerGroupRequest) (*github.RunnerGroup, *github.Response, error)
	createOrganizationRunnerGroupMutex       sync.RWMutex
	createOrganizationRunnerGroupArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 github.CreateRunnerGroupRequest
	}
	createOrganizationRunnerGroupReturns struct {
		result1 *github.RunnerGroup
		result2 *github.Response
		result3 error
	}
	createOrganizationRunnerGroupReturnsOnCall map[int]struct {
		result1 *github.RunnerGroup
		result2 *github.Response
		result3 error
	}
	DeleteOrganizationRunnerGroupStub        func(context.Context, string, int64) (*github.Response, error)
	deleteOrganizationRunnerGroupMutex       sync.RWMutex
	deleteOrganizationRunnerGroupArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int64
	}
	deleteOrganizationRunnerGroupReturns struct {
		result1 *github.Response
		result2 error
	}
	deleteOrganizationRunnerGroupReturnsOnCall map[int]struct {
		result1 *github.Response
		result2 error
	}
	ListOrganizationRunnerGroupsStub        func(context.Context, string, *github.ListOptions) (*github.RunnerGroups, *github.Response, error)
	listOrganizationRunnerGroupsMutex       sync.RWMutex
	listOrganizationRunnerGroupsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 *github.ListOptions
	}
	listOrganizationRunnerGroupsReturns struct {
		result1 *github.RunnerGroups
		result2 *github.Response
		result3 error
	}
	listOrganizationRunnerGroupsReturnsOnCall map[int]struct {
		result1 *github.RunnerGroups
		result2 *github.Response
		result3 error
	}
	ListRepositoryAccessRunnerGroupStub        func(context.Context, string, int64, *github.ListOptions) (*github.ListRepositories, *github.Response, error)
	listRepositoryAccessRunnerGroupMutex       sync.RWMutex
	listRepositoryAccessRunnerGroupArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 *github.ListOptions
	}
	listRepositoryAccessRunnerGroupReturns struct {
		result1 *github.ListRepositories
		result2 *github.Response
		result3 error
	}
	listRepositoryAccessRunnerGroupReturnsOnCall map[int]struct {
		result1 *github.ListRepositories
		result2 *github.Response
		result3 error
	}
	ListRunnerGroupRunnersStub        func(context.Context, string, int64, *github.ListOptions) (*github.Runners, *github.Response, error)
	listRunnerGroupRunnersMutex       sync.RWMutex
	listRunnerGroupRunnersArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 *github.ListOptions
	}
	listRunnerGroupRunnersReturns struct {
		result1 *github.Runners
		result2 *github.Response
		result3 error
	}
	listRunnerGroupRunnersReturnsOnCall map[int]struct {
		result1 *github.Runners
		result2 *github.Response
		result3 error
	}
	RemoveRepositoryAccessRunnerGroupStub        func(context.Context, string, int64, int64) (*github.Response, error)
	removeRepositoryAccessRunnerGroupMutex       sync.RWMutex
	removeRepositoryAccessRunnerGroupArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 int64
	}
	removeRepositoryAccessRunnerGroupReturns struct {
		result1 *github.Response
		result2 error
	}
	removeRepositoryAccessRunnerGroupReturnsOnCall map[int]struct {
		result1 *github.Response
		result2 error
	}
	SetRepositoryAccessRunnerGroupStub        func(context.Context, string, int64, github.SetRepoAccessRunnerGroupRequest) (*github.Response, error)
	setRepositoryAccessRunnerGroupMutex       sync.RWMutex
	setRepositoryAccessRunnerGroupArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 github.SetRepoAccessRunnerGroupRequest
	}
	setRepositoryAccessRunnerGroupReturns struct {
		result1 *github.Response
		result2 error
	}
	setRepositoryAccessRunnerGroupReturnsOnCall map[int]struct {
		result1 *github.Response
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *ActionsClient) AddRepositoryAccessRunnerGroup(arg1 context.Context, arg2 string, arg3 int64, arg4 int64) (*github.Response, error) {
	fake.addRepositoryAccessRunnerGroupMutex.Lock()
	ret, specificReturn := fake.addRepositoryAccessRunnerGroupReturnsOnCall[len(fake.addRepositoryAccessRunnerGroupArgsForCall)]
	fake.addRepositoryAccessRunnerGroupArgsForCall = append(fake.addRepositoryAccessRunnerGroupArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 int64
	}{arg1, arg2, arg3, arg4})
	stub := fake.AddRepositoryAccessRunnerGroupStub
	fakeReturns := fake.addRepositoryAccessRunnerGroupReturns
	fake.recordInvocation("AddRepositoryAccessRunnerGroup", []interface{}{arg1, arg2, arg3, arg4})
	fake.addRepositoryAccessRunnerGroupMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *ActionsClient) AddRepositoryAccessRunnerGroupCallCount() int {
	fake.addRepositoryAccessRunnerGroupMutex.RLock()
	defer fake.addRepositoryAccessRunnerGroupMutex.RUnlock()
	return len(fake.addRepositoryAccessRunnerGroupArgsForCall)
}

func (fake *ActionsClient) AddRepositoryAccessRunnerGroupCalls(stub func(context.Context, string, int64, int64) (*github.Response, error)) {
	fake.addRepositoryAccessRunnerGroupMutex.Lock()
	defer fake.addRepositoryAccessRunnerGroupMutex.Unlock()
	fake.AddRepositoryAccessRunnerGroupStub = stub
}

func (fake *ActionsClient) AddRepositoryAccessRunnerGroupArgsForCall(i int) (context.Context, string, int64, int64) {
	fake.addRepositoryAccessRunnerGroupMutex.RLock()
	defer fake.addRepositoryAccessRunnerGroupMutex.RUnlock()
	argsForCall := fake.addRepositoryAccessRunnerGroupArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *ActionsClient) AddRepositoryAccessRunnerGroupReturns(result1 *github.Response, result2 error) {
	fake.addRepositoryAccessRunnerGroupMutex.Lock()
	defer fake.addRepositoryAccessRunnerGroupMutex.Unlock()
	fake.AddRepositoryAccessRunnerGroupStub = nil
	fake.addRepositoryAccessRunnerGroupReturns = struct {
		result1 *github.Response
		result2 error
	}{result1, result2}
}

func (fake *ActionsClient) AddRepositoryAccessRunnerGroupReturnsOnCall(i int, result1 *github.Response, result2 error) {
	fake.addRepositoryAccessRunnerGroupMutex.Lock()
	defer fake.addRepositoryAccessRunnerGroupMutex.Unlock()
	fake.AddRepositoryAccessRunnerGroupStub = nil
	if fake.addRepositoryAccessRunnerGroupReturnsOnCall == nil {
		fake.addRepositoryAccessRunnerGroupReturnsOnCall = make(map[int]struct {
			result1 *github.Response
			result2 error
		})
	}
	fake.addRepositoryAccessRunnerGroupReturnsOnCall[i] = struct {
		result1 *github.Response
		result2 error
	}{result1, result2}
}

func (fake *ActionsClient) CreateOrganizationRegistrationToken(arg1 context.Context, arg2 string) (*github.RegistrationToken, *github.Response, error) {
	fake.createOrganizationRegistrationTokenMutex.Lock()
	ret, specificReturn := fake.createOrganizationRegistrationTokenReturnsOnCall[len(fake.createOrganizationRegistrationTokenArgsForCall)]
	fake.createOrganizationRegistrationTokenArgsForCall = append(fake.createOrganizationRegistrationTokenArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.CreateOrganizationRegistrationTokenStub
	fakeReturns := fake.createOrganizationRegistrationTokenReturns
	fake.recordInvocation("CreateOrganizationRegistrationToken", []interface{}{arg1, arg2})
	fake.createOrganizationRegistrationTokenMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *ActionsClient) CreateOrganizationRegistrationTokenCallCount() int {
	fake.createOrganizationRegistrationTokenMutex.RLock()
	defer fake.createOrganizationRegistrationTokenMutex.RUnlock()
	return len(fake.createOrganizationRegistrationTokenArgsForCall)
}

func (fake *ActionsClient) CreateOrganizationRegistrationTokenCalls(stub func(context.Context, string) (*github.RegistrationToken, *github.Response, error)) {
	fake.createOrganizationRegistrationTokenMutex.Lock()
	defer fake.createOrganizationRegistrationTokenMutex.Unlock()
	fake.CreateOrganizationRegistrationTokenStub = stub
}

func (fake *ActionsClient) CreateOrganizationRegistrationTokenArgsForCall(i int) (context.Context, string) {
	fake.createOrganizationRegistrationTokenMutex.RLock()
	defer fake.createOrganizationRegistrationTokenMutex.RUnlock()
	argsForCall := fake.createOrganizationRegistrationTokenArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *ActionsClient) CreateOrganizationRegistrationTokenReturns(result1 *github.RegistrationToken, result2 *github.Response, result3 error) {
	fake.createOrganizationRegistrationTokenMutex.Lock()
	defer fake.createOrganizationRegistrationTokenMutex.Unlock()
	fake.CreateOrganizationRegistrationTokenStub = nil
	fake.createOrganizationRegistrationTokenReturns = struct {
		result1 *github.RegistrationToken
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *ActionsClient) CreateOrganizationRegistrationTokenReturnsOnCall(i int, result1 *github.RegistrationToken, result2 *github.Response, result3 error) {
	fake.createOrganizationRegistrationTokenMutex.Lock()
	defer fake.createOrganizationRegistrationTokenMutex.Unlock()
	fake.CreateOrganizationRegistrationTokenStub = nil
	if fake.createOrganizationRegistrationTokenReturnsOnCall == nil {
		fake.createOrganizationRegistrationTokenReturnsOnCall = make(map[int]struct {
			result1 *github.RegistrationToken
			result2 *github.Response
			result3 error
		})
	}
	fake.createOrganizationRegistrationTokenReturnsOnCall[i] = struct {
		result1 *github.RegistrationToken
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *ActionsClient) CreateOrganizationRemoveToken(arg1 context.Context, arg2 string) (*github.RemoveToken, *github.Response, error) {
	fake.createOrganizationRemoveTokenMutex.Lock()
	ret, specificReturn := fake.createOrganizationRemoveTokenReturnsOnCall[len(fake.createOrganizationRemoveTokenArgsForCall)]
	fake.createOrganizationRemoveTokenArgsForCall = append(fake.createOrganizationRemoveTokenArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.CreateOrganizationRemoveTokenStub
	fakeReturns := fake.createOrganizationRemoveTokenReturns
	fake.recordInvocation("CreateOrganizationRemoveToken", []interface{}{arg1, arg2})
	fake.createOrganizationRemoveTokenMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *ActionsClient) CreateOrganizationRemoveTokenCallCount() int {
	fake.createOrganizationRemoveTokenMutex.RLock()
	defer fake.createOrganizationRemoveTokenMutex.RUnlock()
	return len(fake.createOrganizationRemoveTokenArgsForCall)
}

func (fake *ActionsClient) CreateOrganizationRemoveTokenCalls(stub func(context.Context, string) (*github.RemoveToken, *github.Response, error)) {
	fake.createOrganizationRemoveTokenMutex.Lock()
	defer fake.createOrganizationRemoveTokenMutex.Unlock()
	fake.CreateOrganizationRemoveTokenStub = stub
}

func (fake *ActionsClient) CreateOrganizationRemoveTokenArgsForCall(i int) (context.Context, string) {
	fake.createOrganizationRemoveTokenMutex.RLock()
	defer fake.createOrganizationRemoveTokenMutex.RUnlock()
	argsForCall := fake.createOrganizationRemoveTokenArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *ActionsClient) CreateOrganizationRemoveTokenReturns(result1 *github.RemoveToken, result2 *github.Response, result3 error) {
	fake.createOrganizationRemoveTokenMutex.Lock()
	defer fake.createOrganizationRemoveTokenMutex.Unlock()
	fake.CreateOrganizationRemoveTokenStub = nil
	fake.createOrganizationRemoveTokenReturns = struct {
		result1 *github.RemoveToken
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *ActionsClient) CreateOrganizationRemoveTokenReturnsOnCall(i int, result1 *github.RemoveToken, result2 *github.Response, result3 error) {
	fake.createOrganizationRemoveTokenMutex.Lock()
	defer fake.createOrganizationRemoveTokenMutex.Unlock()
	fake.CreateOrganizationRemoveTokenStub = nil
	if fake.createOrganizationRemoveTokenReturnsOnCall == nil {
		fake.createOrganizationRemoveTokenReturnsOnCall = make(map[int]struct {
			result1 *github.RemoveToken
			result2 *github.Response
			result3 error
		})
	}
	fake.createOrganizationRemoveTokenReturnsOnCall[i] = struct {
		result1 *github.RemoveToken
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *ActionsClient) CreateOrganizationRunnerGroup(arg1 context.Context, arg2 string, arg3 github.CreateRunnerGroupRequest) (*github.RunnerGroup, *github.Response, error) {
	fake.createOrganizationRunnerGroupMutex.Lock()
	ret, specificReturn := fake.createOrganizationRunnerGroupReturnsOnCall[len(fake.createOrganizationRunnerGroupArgsForCall)]
	fake.createOrganizationRunnerGroupArgsForCall = append(fake.createOrganizationRunnerGroupArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 github.CreateRunnerGroupRequest
	}{arg1, arg2, arg3})
	stub := fake.CreateOrganizationRunnerGroupStub
	fakeReturns := fake.createOrganizationRunnerGroupReturns
	fake.recordInvocation("CreateOrganizationRunnerGroup", []interface{}{arg1, arg2, arg3})
	fake.createOrganizationRunnerGroupMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *ActionsClient) CreateOrganizationRunnerGroupCallCount() int {
	fake.createOrganizationRunnerGroupMutex.RLock()
	defer fake.createOrganizationRunnerGroupMutex.RUnlock()
	return len(fake.createOrganizationRunnerGroupArgsForCall)
}

func (fake *ActionsClient) CreateOrganizationRunnerGroupCalls(stub func(context.Context, string, github.CreateRunnerGroupRequest) (*github.RunnerGroup, *github.Response, error)) {
	fake.createOrganizationRunnerGroupMutex.Lock()
	defer fake.createOrganizationRunnerGroupMutex.Unlock()
	fake.CreateOrganizationRunnerGroupStub = stub
}

func (fake *ActionsClient) CreateOrganizationRunnerGroupArgsForCall(i int) (context.Context, string, github.CreateRunnerGroupRequest) {
	fake.createOrganizationRunnerGroupMutex.RLock()
	defer fake.createOrganizationRunnerGroupMutex.RUnlock()
	argsForCall := fake.createOrganizationRunnerGroupArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *ActionsClient) CreateOrganizationRunnerGroupReturns(result1 *github.RunnerGroup, result2 *github.Response, result3 error) {
	fake.createOrganizationRunnerGroupMutex.Lock()
	defer fake.createOrganizationRunnerGroupMutex.Unlock()
	fake.CreateOrganizationRunnerGroupStub = nil
	fake.createOrganizationRunnerGroupReturns = struct {
		result1 *github.RunnerGroup
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *ActionsClient) CreateOrganizationRunnerGroupReturnsOnCall(i int, result1 *github.RunnerGroup, result2 *github.Response, result3 error) {
	fake.createOrganizationRunnerGroupMutex.Lock()
	defer fake.createOrganizationRunnerGroupMutex.Unlock()
	fake.CreateOrganizationRunnerGroupStub = nil
	if fake.createOrganizationRunnerGroupReturnsOnCall == nil {
		fake.createOrganizationRunnerGroupReturnsOnCall = make(map[int]struct {
			result1 *github.RunnerGroup
			result2 *github.Response
			result3 error
		})
	}
	fake.createOrganizationRunnerGroupReturnsOnCall[i] = struct {
		result1 *github.RunnerGroup
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *ActionsClient) DeleteOrganizationRunnerGroup(arg1 context.Context, arg2 string, arg3 int64) (*github.Response, error) {
	fake.deleteOrganizationRunnerGroupMutex.Lock()
	ret, specificReturn := fake.deleteOrganizationRunnerGroupReturnsOnCall[len(fake.deleteOrganizationRunnerGroupArgsForCall)]
	fake.deleteOrganizationRunnerGroupArgsForCall = append(fake.deleteOrganizationRunnerGroupArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int64
	}{arg1, arg2, arg3})
	stub := fake.DeleteOrganizationRunnerGroupStub
	fakeReturns := fake.deleteOrganizationRunnerGroupReturns
	fake.recordInvocation("DeleteOrganizationRunnerGroup", []interface{}{arg1, arg2, arg3})
	fake.deleteOrganizationRunnerGroupMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *ActionsClient) DeleteOrganizationRunnerGroupCallCount() int {
	fake.deleteOrganizationRunnerGroupMutex.RLock()
	defer fake.deleteOrganizationRunnerGroupMutex.RUnlock()
	return len(fake.deleteOrganizationRunnerGroupArgsForCall)
}

func (fake *ActionsClient) DeleteOrganizationRunnerGroupCalls(stub func(context.Context, string, int64) (*github.Response, error)) {
	fake.deleteOrganizationRunnerGroupMutex.Lock()
	defer fake.deleteOrganizationRunnerGroupMutex.Unlock()
	fake.DeleteOrganizationRunnerGroupStub = stub
}

func (fake *ActionsClient) DeleteOrganizationRunnerGroupArgsForCall(i int) (context.Context, string, int64) {
	fake.deleteOrganizationRunnerGroupMutex.RLock()
	defer fake.deleteOrganizationRunnerGroupMutex.RUnlock()
	argsForCall := fake.deleteOrganizationRunnerGroupArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *ActionsClient) DeleteOrganizationRunnerGroupReturns(result1 *github.Response, result2 error) {
	fake.deleteOrganizationRunnerGroupMutex.Lock()
	defer fake.deleteOrganizationRunnerGroupMutex.Unlock()
	fake.DeleteOrganizationRunnerGroupStub = nil
	fake.deleteOrganizationRunnerGroupReturns = struct {
		result1 *github.Response
		result2 error
	}{result1, result2}
}

func (fake *ActionsClient) DeleteOrganizationRunnerGroupReturnsOnCall(i int, result1 *github.Response, result2 error) {
	fake.deleteOrganizationRunnerGroupMutex.Lock()
	defer fake.deleteOrganizationRunnerGroupMutex.Unlock()
	fake.DeleteOrganizationRunnerGroupStub = nil
	if fake.deleteOrganizationRunnerGroupReturnsOnCall == nil {
		fake.deleteOrganizationRunnerGroupReturnsOnCall = make(map[int]struct {
			result1 *github.Response
			result2 error
		})
	}
	fake.deleteOrganizationRunnerGroupReturnsOnCall[i] = struct {
		result1 *github.Response
		result2 error
	}{result1, result2}
}

func (fake *ActionsClient) ListOrganizationRunnerGroups(arg1 context.Context, arg2 string, arg3 *github.ListOptions) (*github.RunnerGroups, *github.Response, error) {
	fake.listOrganizationRunnerGroupsMutex.Lock()
	ret, specificReturn := fake.listOrganizationRunnerGroupsReturnsOnCall[len(fake.listOrganizationRunnerGroupsArgsForCall)]
	fake.listOrganizationRunnerGroupsArgsForCall = append(fake.listOrganizationRunnerGroupsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 *github.ListOptions
	}{arg1, arg2, arg3})
	stub := fake.ListOrganizationRunnerGroupsStub
	fakeReturns := fake.listOrganizationRunnerGroupsReturns
	fake.recordInvocation("ListOrganizationRunnerGroups", []interface{}{arg1, arg2, arg3})
	fake.listOrganizationRunnerGroupsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *ActionsClient) ListOrganizationRunnerGroupsCallCount() int {
	fake.listOrganizationRunnerGroupsMutex.RLock()
	defer fake.listOrganizationRunnerGroupsMutex.RUnlock()
	return len(fake.listOrganizationRunnerGroupsArgsForCall)
}

func (fake *ActionsClient) ListOrganizationRunnerGroupsCalls(stub func(context.Context, string, *github.ListOptions) (*github.RunnerGroups, *github.Response, error)) {
	fake.listOrganizationRunnerGroupsMutex.Lock()
	defer fake.listOrganizationRunnerGroupsMutex.Unlock()
	fake.ListOrganizationRunnerGroupsStub = stub
}

func (fake *ActionsClient) ListOrganizationRunnerGroupsArgsForCall(i int) (context.Context, string, *github.ListOptions) {
	fake.listOrganizationRunnerGroupsMutex.RLock()
	defer fake.listOrganizationRunnerGroupsMutex.RUnlock()
	argsForCall := fake.listOrganizationRunnerGroupsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *ActionsClient) ListOrganizationRunnerGroupsReturns(result1 *github.RunnerGroups, result2 *github.Response, result3 error) {
	fake.listOrganizationRunnerGroupsMutex.Lock()
	defer fake.listOrganizationRunnerGroupsMutex.Unlock()
	fake.ListOrganizationRunnerGroupsStub = nil
	fake.listOrganizationRunnerGroupsReturns = struct {
		result1 *github.RunnerGroups
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *ActionsClient) ListOrganizationRunnerGroupsReturnsOnCall(i int, result1 *github.RunnerGroups, result2 *github.Response, result3 error) {
	fake.listOrganizationRunnerGroupsMutex.Lock()
	defer fake.listOrganizationRunnerGroupsMutex.Unlock()
	fake.ListOrganizationRunnerGroupsStub = nil
	if fake.listOrganizationRunnerGroupsReturnsOnCall == nil {
		fake.listOrganizationRunnerGroupsReturnsOnCall = make(map[int]struct {
			result1 *github.RunnerGroups
			result2 *github.Response
			result3 error
		})
	}
	fake.listOrganizationRunnerGroupsReturnsOnCall[i] = struct {
		result1 *github.RunnerGroups
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *ActionsClient) ListRepositoryAccessRunnerGroup(arg1 context.Context, arg2 string, arg3 int64, arg4 *github.ListOptions) (*github.ListRepositories, *github.Response, error) {
	fake.listRepositoryAccessRunnerGroupMutex.Lock()
	ret, specificReturn := fake.listRepositoryAccessRunnerGroupReturnsOnCall[len(fake.listRepositoryAccessRunnerGroupArgsForCall)]
	fake.listRepositoryAccessRunnerGroupArgsForCall = append(fake.listRepositoryAccessRunnerGroupArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 *github.ListOptions
	}{arg1, arg2, arg3, arg4})
	stub := fake.ListRepositoryAccessRunnerGroupStub
	fakeReturns := fake.listRepositoryAccessRunnerGroupReturns
	fake.recordInvocation("ListRepositoryAccessRunnerGroup", []interface{}{arg1, arg2, arg3, arg4})
	fake.listRepositoryAccessRunnerGroupMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *ActionsClient) ListRepositoryAccessRunnerGroupCallCount() int {
	fake.listRepositoryAccessRunnerGroupMutex.RLock()
	defer fake.listRepositoryAccessRunnerGroupMutex.RUnlock()
	return len(fake.listRepositoryAccessRunnerGroupArgsForCall)
}

func (fake *ActionsClient) ListRepositoryAccessRunnerGroupCalls(stub func(context.Context, string, int64, *github.ListOptions) (*github.ListRepositories, *github.Response, error)) {
	fake.listRepositoryAccessRunnerGroupMutex.Lock()
	defer fake.listRepositoryAccessRunnerGroupMutex.Unlock()
	fake.ListRepositoryAccessRunnerGroupStub = stub
}

func (fake *ActionsClient) ListRepositoryAccessRunnerGroupArgsForCall(i int) (context.Context, string, int64, *github.ListOptions) {
	fake.listRepositoryAccessRunnerGroupMutex.RLock()
	defer fake.listRepositoryAccessRunnerGroupMutex.RUnlock()
	argsForCall := fake.listRepositoryAccessRunnerGroupArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *ActionsClient) ListRepositoryAccessRunnerGroupReturns(result1 *github.ListRepositories, result2 *github.Response, result3 error) {
	fake.listRepositoryAccessRunnerGroupMutex.Lock()
	defer fake.listRepositoryAccessRunnerGroupMutex.Unlock()
	fake.ListRepositoryAccessRunnerGroupStub = nil
	fake.listRepositoryAccessRunnerGroupReturns = struct {
		result1 *github.ListRepositories
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *ActionsClient) ListRepositoryAccessRunnerGroupReturnsOnCall(i int, result1 *github.ListRepositories, result2 *github.Response, result3 error) {
	fake.listRepositoryAccessRunnerGroupMutex.Lock()
	defer fake.listRepositoryAccessRunnerGroupMutex.Unlock()
	fake.ListRepositoryAccessRunnerGroupStub = nil
	if fake.listRepositoryAccessRunnerGroupReturnsOnCall == nil {
		fake.listRepositoryAccessRunnerGroupReturnsOnCall = make(map[int]struct {
			result1 *github.ListRepositories
			result2 *github.Response
			result3 error
		})
	}
	fake.listRepositoryAccessRunnerGroupReturnsOnCall[i] = struct {
		result1 *github.ListRepositories
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *ActionsClient) ListRunnerGroupRunners(arg1 context.Context, arg2 string, arg3 int64, arg4 *github.ListOptions) (*github.Runners, *github.Response, error) {
	fake.listRunnerGroupRunnersMutex.Lock()
	ret, specificReturn := fake.listRunnerGroupRunnersReturnsOnCall[len(fake.listRunnerGroupRunnersArgsForCall)]
	fake.listRunnerGroupRunnersArgsForCall = append(fake.listRunnerGroupRunnersArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 *github.ListOptions
	}{arg1, arg2, arg3, arg4})
	stub := fake.ListRunnerGroupRunnersStub
	fakeReturns := fake.listRunnerGroupRunnersReturns
	fake.recordInvocation("ListRunnerGroupRunners", []interface{}{arg1, arg2, arg3, arg4})
	fake.listRunnerGroupRunnersMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *ActionsClient) ListRunnerGroupRunnersCallCount() int {
	fake.listRunnerGroupRunnersMutex.RLock()
	defer fake.listRunnerGroupRunnersMutex.RUnlock()
	return len(fake.listRunnerGroupRunnersArgsForCall)
}

func (fake *ActionsClient) ListRunnerGroupRunnersCalls(stub func(context.Context, string, int64, *github.ListOptions) (*github.Runners, *github.Response, error)) {
	fake.listRunnerGroupRunnersMutex.Lock()
	defer fake.listRunnerGroupRunnersMutex.Unlock()
	fake.ListRunnerGroupRunnersStub = stub
}

func (fake *ActionsClient) ListRunnerGroupRunnersArgsForCall(i int) (context.Context, string, int64, *github.ListOptions) {
	fake.listRunnerGroupRunnersMutex.RLock()
	defer fake.listRunnerGroupRunnersMutex.RUnlock()
	argsForCall := fake.listRunnerGroupRunnersArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *ActionsClient) ListRunnerGroupRunnersReturns(result1 *github.Runners, result2 *github.Response, result3 error) {
	fake.listRunnerGroupRunnersMutex.Lock()
	defer fake.listRunnerGroupRunnersMutex.Unlock()
	fake.ListRunnerGroupRunnersStub = nil
	fake.listRunnerGroupRunnersReturns = struct {
		result1 *github.Runners
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *ActionsClient) ListRunnerGroupRunnersReturnsOnCall(i int, result1 *github.Runners, result2 *github.Response, result3 error) {
	fake.listRunnerGroupRunnersMutex.Lock()
	defer fake.listRunnerGroupRunnersMutex.Unlock()
	fake.ListRunnerGroupRunnersStub = nil
	if fake.listRunnerGroupRunnersReturnsOnCall == nil {
		fake.listRunnerGroupRunnersReturnsOnCall = make(map[int]struct {
			result1 *github.Runners
			result2 *github.Response
			result3 error
		})
	}
	fake.listRunnerGroupRunnersReturnsOnCall[i] = struct {
		result1 *github.Runners
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *ActionsClient) RemoveRepositoryAccessRunnerGroup(arg1 context.Context, arg2 string, arg3 int64, arg4 int64) (*github.Response, error) {
	fake.removeRepositoryAccessRunnerGroupMutex.Lock()
	ret, specificReturn := fake.removeRepositoryAccessRunnerGroupReturnsOnCall[len(fake.removeRepositoryAccessRunnerGroupArgsForCall)]
	fake.removeRepositoryAccessRunnerGroupArgsForCall = append(fake.removeRepositoryAccessRunnerGroupArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 int64
	}{arg1, arg2, arg3, arg4})
	stub := fake.RemoveRepositoryAccessRunnerGroupStub
	fakeReturns := fake.removeRepositoryAccessRunnerGroupReturns
	fake.recordInvocation("RemoveRepositoryAccessRunnerGroup", []interface{}{arg1, arg2, arg3, arg4})
	fake.removeRepositoryAccessRunnerGroupMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *ActionsClient) RemoveRepositoryAccessRunnerGroupCallCount() int {
	fake.removeRepositoryAccessRunnerGroupMutex.RLock()
	defer fake.removeRepositoryAccessRunnerGroupMutex.RUnlock()
	return len(fake.removeRepositoryAccessRunnerGroupArgsForCall)
}

func (fake *ActionsClient) RemoveRepositoryAccessRunnerGroupCalls(stub func(context.Context, string, int64, int64) (*github.Response, error)) {
	fake.removeRepositoryAccessRunnerGroupMutex.Lock()
	defer fake.removeRepositoryAccessRunnerGroupMutex.Unlock()
	fake.RemoveRepositoryAccessRunnerGroupStub = stub
}

func (fake *ActionsClient) RemoveRepositoryAccessRunnerGroupArgsForCall(i int) (context.Context, string, int64, int64) {
	fake.removeRepositoryAccessRunnerGroupMutex.RLock()
	defer fake.removeRepositoryAccessRunnerGroupMutex.RUnlock()
	argsForCall := fake.removeRepositoryAccessRunnerGroupArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *ActionsClient) RemoveRepositoryAccessRunnerGroupReturns(result1 *github.Response, result2 error) {
	fake.removeRepositoryAccessRunnerGroupMutex.Lock()
	defer fake.removeRepositoryAccessRunnerGroupMutex.Unlock()
	fake.RemoveRepositoryAccessRunnerGroupStub = nil
	fake.removeRepositoryAccessRunnerGroupReturns = struct {
		result1 *github.Response
		result2 error
	}{result1, result2}
}

func (fake *ActionsClient) RemoveRepositoryAccessRunnerGroupReturnsOnCall(i int, result1 *github.Response, result2 error) {
	fake.removeRepositoryAccessRunnerGroupMutex.Lock()
	defer fake.removeRepositoryAccessRunnerGroupMutex.Unlock()
	fake.RemoveRepositoryAccessRunnerGroupStub = nil
	if fake.removeRepositoryAccessRunnerGroupReturnsOnCall == nil {
		fake.removeRepositoryAccessRunnerGroupReturnsOnCall = make(map[int]struct {
			result1 *github.Response
			result2 error
		})
	}
	fake.removeRepositoryAccessRunnerGroupReturnsOnCall[i] = struct {
		result1 *github.Response
		result2 error
	}{result1, result2}
}

func (fake *ActionsClient) SetRepositoryAccessRunnerGroup(arg1 context.Context, arg2 string, arg3 int64, arg4 github.SetRepoAccessRunnerGroupRequest) (*github.Response, error) {
	fake.setRepositoryAccessRunnerGroupMutex.Lock()
	ret, specificReturn := fake.setRepositoryAccessRunnerGroupReturnsOnCall[len(fake.setRepositoryAccessRunnerGroupArgsForCall)]
	fake.setRepositoryAccessRunnerGroupArgsForCall = append(fake.setRepositoryAccessRunnerGroupArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 github.SetRepoAccessRunnerGroupRequest
	}{arg1, arg2, arg3, arg4})
	stub := fake.SetRepositoryAccessRunnerGroupStub
	fakeReturns := fake.setRepositoryAccessRunnerGroupReturns
	fake.recordInvocation("SetRepositoryAccessRunnerGroup", []interface{}{arg1, arg2, arg3, arg4})
	fake.setRepositoryAccessRunnerGroupMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *ActionsClient) SetRepositoryAccessRunnerGroupCallCount() int {
	fake.setRepositoryAccessRunnerGroupMutex.RLock()
	defer fake.setRepositoryAccessRunnerGroupMutex.RUnlock()
	return len(fake.setRepositoryAccessRunnerGroupArgsForCall)
}

func (fake *ActionsClient) SetRepositoryAccessRunnerGroupCalls(stub func(context.Context, string, int64, github.SetRepoAccessRunnerGroupRequest) (*github.Response, error)) {
	fake.setRepositoryAccessRunnerGroupMutex.Lock()
	defer fake.setRepositoryAccessRunnerGroupMutex.Unlock()
	fake.SetRepositoryAccessRunnerGroupStub = stub
}

func (fake *ActionsClient) SetRepositoryAccessRunnerGroupArgsForCall(i int) (context.Context, string, int64, github.SetRepoAccessRunnerGroupRequest) {
	fake.setRepositoryAccessRunnerGroupMutex.RLock()
	defer fake.setRepositoryAccessRunnerGroupMutex.RUnlock()
	argsForCall := fake.setRepositoryAccessRunnerGroupArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *ActionsClient) SetRepositoryAccessRunnerGroupReturns(result1 *github.Response, result2 error) {
	fake.setRepositoryAccessRunnerGroupMutex.Lock()
	defer fake.setRepositoryAccessRunnerGroupMutex.Unlock()
	fake.SetRepositoryAccessRunnerGroupStub = nil
	fake.setRepositoryAccessRunnerGroupReturns = struct {
		result1 *github.Response
		result2 error
	}{result1, result2}
}

func (fake *ActionsClient) SetRepositoryAccessRunnerGroupReturnsOnCall(i int, result1 *github.Response, result2 error) {
	fake.setRepositoryAccessRunnerGroupMutex.Lock()
	defer fake.setRepositoryAccessRunnerGroupMutex.Unlock()
	fake.SetRepositoryAccessRunnerGroupStub = nil
	if fake.setRepositoryAccessRunnerGroupReturnsOnCall == nil {
		fake.setRepositoryAccessRunnerGroupReturnsOnCall = make(map[int]struct {
			result1 *github.Response
			result2 error
		})
	}
	fake.setRepositoryAccessRunnerGroupReturnsOnCall[i] = struct {
		result1 *github.Response
		result2 error
	}{result1, result2}
}

func (fake *ActionsClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addRepositoryAccessRunnerGroupMutex.RLock()
	defer fake.addRepositoryAccessRunnerGroupMutex.RUnlock()
	fake.createOrganizationRegistrationTokenMutex.RLock()
	defer fake.createOrganizationRegistrationTokenMutex.RUnlock()
	fake.createOrganizationRemoveTokenMutex.RLock()
	defer fake.createOrganizationRemoveTokenMutex.RUnlock()
	fake.createOrganizationRunnerGroupMutex.RLock()
	defer fake.createOrganizationRunnerGroupMutex.RUnlock()
	fake.deleteOrganizationRunnerGroupMutex.RLock()
	defer fake.deleteOrganizationRunnerGroupMutex.RUnlock()
	fake.listOrganizationRunnerGroupsMutex.RLock()
	defer fake.listOrganizationRunnerGroupsMutex.RUnlock()
	fake.listRepositoryAccessRunnerGroupMutex.RLock()
	defer fake.listRepositoryAccessRunnerGroupMutex.RUnlock()
	fake.listRunnerGroupRunnersMutex.RLock()
	defer fake.listRunnerGroupRunnersMutex.RUnlock()
	fake.removeRepositoryAccessRunnerGroupMutex.RLock()
	defer fake.removeRepositoryAccessRunnerGroupMutex.RUnlock()
	fake.setRepositoryAccessRunnerGroupMutex.RLock()
	defer fake.setRepositoryAccessRunnerGroupMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *ActionsClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
